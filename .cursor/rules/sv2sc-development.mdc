---
alwaysApply: true
---
# SV2SC Development Workflow Rules

## Project Structure

### Core Components
- **Main Application**: [src/sv2sc.cpp](mdc:src/sv2sc.cpp) - Entry point and CLI handling
- **Standard Pipeline**: [src/core/](mdc:src/core/) - Direct SystemVerilog to SystemC translation
- **MLIR Pipeline**: [src/mlir/](mdc:src/mlir/) - MLIR/CIRCT-based translation
- **Code Generation**: [src/codegen/](mdc:src/codegen/) - SystemC code generation
- **Utilities**: [src/utils/](mdc:src/utils/) - Logging, error handling, utilities

### Key Files
- **Build System**: [CMakeLists.txt](mdc:CMakeLists.txt) - Main build configuration
- **Dependencies**: [cmake/Dependencies.cmake](mdc:cmake/Dependencies.cmake) - External dependency management
- **Testing**: [cmake/SystemCTestUtils.cmake](mdc:cmake/SystemCTestUtils.cmake) - Test infrastructure
- **Documentation**: [output/](mdc:output/) - Generated reports and analysis

## Development Workflow

### 1. Feature Development
```bash
# Start with mock CIRCT for rapid iteration
cmake -B build -DSV2SC_ENABLE_MLIR=ON
cmake --build build -j$(nproc)

# Test with standard pipeline first
./build/src/sv2sc -top module design.sv

# Then test with MLIR pipeline
./build/src/sv2sc --use-mlir -top module design.sv
```

### 2. MLIR Development
When working on MLIR components:
1. **Use mock CIRCT** for initial development
2. **Test with simple modules** first
3. **Add complexity gradually** to avoid stack overflow
4. **Enable full CIRCT** only for final testing

### 3. Testing Strategy
```bash
# Quick validation
./build/src/sv2sc --use-mlir -top memory tests/examples/memory_array/memory.sv
./build/src/sv2sc --use-mlir -top generate_adder tests/examples/generate_example/generate_adder.sv

# Full regression test
for f in tests/examples/*/*.sv; do
    ./build/src/sv2sc --use-mlir -top "$(basename "$f" .sv)" "$f"
done

# Complex design test
./build/src/sv2sc --use-mlir -top picorv32 third-party/picorv32/picorv32.v
```

## Coding Standards

### C++ Standards
- **Language**: C++20 with all modern features
- **Memory Management**: Smart pointers, RAII, avoid raw pointers
- **Error Handling**: Comprehensive exception safety
- **Naming**: camelCase for functions/variables, PascalCase for types

### MLIR/CIRCT Best Practices
```cpp
// Always use InsertionGuard for nested operations
mlir::OpBuilder::InsertionGuard guard(builder_);

// Check types safely
if (llvm::isa<mlir::IntegerType>(type)) {
    auto intType = llvm::cast<mlir::IntegerType>(type);
    // Use intType safely
}

// Wrap critical operations in try-catch
try {
    auto result = builder_.create<circt::hw::ConstantOp>(loc, type, attr);
} catch (const std::exception& e) {
    LOG_ERROR("Failed to create operation: {}", e.what());
    return nullptr;
}
```

### Error Handling
```cpp
// Comprehensive error reporting
void addError(const std::string& error) {
    errors_.push_back(error);
    LOG_ERROR(error);
}

// Graceful degradation
if (!operation) {
    LOG_WARN("Operation failed, using fallback");
    return createFallbackOperation();
}
```

## Debugging Guidelines

### Common Issues
1. **Segmentation Faults**: Usually caused by invalid MLIR structures
2. **Infinite Recursion**: Check procedural block processing
3. **Linker Errors**: Verify CIRCT library availability
4. **Performance Issues**: Check operation count limits

### Debug Commands
```bash
# Debug with GDB
gdb --args ./build/src/sv2sc --use-mlir -top module design.sv

# Verbose output
./build/src/sv2sc --use-mlir --verbose -top module design.sv

# Check generated files
ls -la output/
cat output/module.h
```

### Log Analysis
```bash
# Check for errors
./build/src/sv2sc --use-mlir -top module design.sv 2>&1 | grep -i error

# Check for warnings
./build/src/sv2sc --use-mlir -top module design.sv 2>&1 | grep -i warn

# Check performance
./build/src/sv2sc --use-mlir -top module design.sv 2>&1 | grep "Translation time"
```

## Performance Optimization

### Build Performance
```bash
# Use ccache for faster rebuilds
export CCACHE_DIR=/path/to/ccache
cmake -B build -DCMAKE_CXX_COMPILER_LAUNCHER=ccache

# Parallel builds
cmake --build build -j$(nproc)

# Incremental builds
cmake --build build --target sv2sc -j$(nproc)
```

### Runtime Performance
- **Release builds** are 2-3x faster than Debug
- **MLIR mode** provides 1.5-45x speedup over standard mode
- **Complex designs** benefit most from MLIR optimization

### Performance Monitoring
```bash
# Profile with perf
perf record ./build/src/sv2sc --use-mlir -top module design.sv
perf report

# Memory profiling
valgrind --tool=massif ./build/src/sv2sc --use-mlir -top module design.sv
ms_print massif.out.* > memory_report.txt
```

## Quality Assurance

### Code Quality
```bash
# Static analysis
cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
run-clang-tidy -p build src/

# Code coverage
cmake -B build -DCMAKE_BUILD_TYPE=Debug -DBUILD_COVERAGE=ON
ctest --test-dir build
lcov --capture --directory build --output-file coverage.info
genhtml coverage.info --output-directory coverage_report
```

### Testing Requirements
- **Unit tests** for all new components
- **Integration tests** for pipeline changes
- **Performance regression** testing
- **Memory leak** detection

## Release Process

### Pre-release Checklist
1. **All tests pass** in both standard and MLIR modes
2. **Performance benchmarks** meet targets
3. **Documentation updated** in [output/](mdc:output/) directory
4. **Code coverage** above 80%
5. **Static analysis** passes

### Release Commands
```bash
# Full build with all features
cmake -B build \
  -DSV2SC_ENABLE_MLIR=ON \
  -DSV2SC_ENABLE_FULL_LLVM=ON \
  -DSV2SC_ENABLE_FULL_CIRCT=ON \
  -DCMAKE_BUILD_TYPE=Release

cmake --build build -j$(nproc)

# Full regression test
for f in tests/examples/*/*.sv third-party/picorv32/picorv32.v; do
    ./build/src/sv2sc --use-mlir -top "$(basename "$f" .sv)" "$f"
done

# Performance validation
./build/src/sv2sc --use-mlir -top picorv32 third-party/picorv32/picorv32.v
# Should complete in <10ms
```

## Documentation

### Code Documentation
- Use Doxygen comments for public APIs
- Document complex algorithms and design decisions
- Maintain up-to-date README.md and CLAUDE.md

### Generated Reports
Key reports in [output/](mdc:output/):
- [output/MLIR_FINAL_IMPLEMENTATION_REPORT.md](mdc:output/MLIR_FINAL_IMPLEMENTATION_REPORT.md) - Complete implementation guide
- [output/PICORV32_FIX_REPORT.md](mdc:output/PICORV32_FIX_REPORT.md) - PicoRV32 fix documentation
- [output/MLIR_ARCHITECTURE_ANALYSIS.md](mdc:output/MLIR_ARCHITECTURE_ANALYSIS.md) - Technical architecture details

## Future Development

### Short Term Goals (1-2 weeks)
1. Implement proper seq::CompRegOp with regions
2. Add comb operations for combinational blocks
3. Create proper MLIR regions for procedural blocks
4. Improve output value tracking

### Medium Term Goals (1-2 months)
1. Full CIRCT operation coverage
2. MLIR optimization passes
3. Direct SystemC emission via CIRCT
4. Performance profiling and tuning

### Long Term Goals (3-6 months)
1. Complete HLS integration
2. Formal verification support
3. Advanced optimization strategies
4. Full CPU design support

## Best Practices Summary

### Do's
- ✅ Use InsertionGuard for nested MLIR operations
- ✅ Check operation count before walking modules
- ✅ Wrap critical operations in try-catch blocks
- ✅ Test with mock CIRCT first, then full CIRCT
- ✅ Document all public APIs and complex logic
- ✅ Run full test suite before committing

### Don'ts
- ❌ Call buildStatement() without proper MLIR regions
- ❌ Skip error handling in critical paths
- ❌ Use raw pointers for memory management
- ❌ Commit without running tests
- ❌ Ignore performance regressions
- ❌ Skip documentation for new features
